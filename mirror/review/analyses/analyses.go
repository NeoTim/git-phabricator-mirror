package analyses

import (
	"encoding/json"
	"github.com/google/git-phabricator-mirror/mirror/repository"
	"io/ioutil"
	"log"
	"net/http"
	"sort"
	"strconv"
)

const (
	// Ref defines the git-notes ref that we expect to contain analysis reports.
	Ref = "refs/notes/devtools/analyses"

	// FormatVersion defines the latest version of the request format supported by the tool.
	FormatVersion = 0
)

// Report represents a build/test status report generated by analyses tool.
// Every field is optional.
type Report struct {
	Timestamp string `json:"timestamp,omitempty"`
	URL       string `json:"url,omitempty"`
	// Version represents the version of the metadata format.
	Version int `json:"v,omitempty"`
}

type LocationRange struct {
	StartLine int `json:"start_line,omitempty"`
}

type Location struct {
	Path  string        `json:"path,omitempty"`
	Range LocationRange `json:"range,omitempty"`
}

type Note struct {
	Location    Location `json:"location,omitempty"`
	Category    string   `json:"category,omitempty"`
	Description string   `json:"description"`
}

type AnalyzeResponse struct {
	Notes []Note `json:"note,omitempty"`
}

type ReportDetails struct {
	AnalyzeResponse []AnalyzeResponse `json:"analyze_response,omitempty"`
}

func (lintReport Report) GetLintReportResult() ([]AnalyzeResponse, error) {
	res, err := http.Get(lintReport.URL)
	if err != nil {
		log.Fatal(err)
	}
	analysesResults, err := ioutil.ReadAll(res.Body)
	res.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Analyses Results %s", analysesResults)
	var details ReportDetails
	err = json.Unmarshal([]byte(analysesResults), &details)
	if err != nil {
		return nil, err
	}
	return details.AnalyzeResponse, nil
}

// Parse parses a CI report from a git note.
func Parse(note repository.Note) (Report, error) {
	bytes := []byte(note)
	var report Report
	err := json.Unmarshal(bytes, &report)
	return report, err
}

// This is currently just taking the last report.
// We could change this behavior to download all reports and
// eliminate duplicates if need be
func GetLatestAnalysesReport(notes []repository.Note) Report {
	timestampReportMap := make(map[int]Report)
	var timestamps []int

	validAnalysesReports := ParseAllValid(notes)
	for _, report := range validAnalysesReports {
		timestamp, err := strconv.Atoi(report.Timestamp)
		if err != nil {
			log.Fatal(err)
		}
		timestamps = append(timestamps, timestamp)
		timestampReportMap[timestamp] = report
	}
	if len(timestamps) == 0 {
		return Report{}
	}
	sort.Sort(sort.Reverse(sort.IntSlice(timestamps)))
	return timestampReportMap[timestamps[0]]
}

// ParseAllValid takes collection of git notes and tries to parse a analyses report
// from each one. Any notes that are not valid analyses reports get ignored.
func ParseAllValid(notes []repository.Note) []Report {
	var reports []Report
	for _, note := range notes {
		report, err := Parse(note)
		if err == nil && report.Version == FormatVersion {
			reports = append(reports, report)
		}
	}
	return reports
}
